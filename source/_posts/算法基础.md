---
layout: _draft
title: 算法基础
date: 2017-09-01 14:19:53
tags: 碎片整理
categories: 碎片整理
---


> 对排序结果，进行二分法查找    
> 交换类：快速和冒泡
> 插入类：简单插入和希尔
> 选择类：简单选择和堆
> 归并类：二路归并和多路归并

算法导论 看了几章啃不动 放一放先 反过去整理了一下算法入门 

<!--more-->

## 选择排序

### 简述
对A数组进行每次查找最小数值的操作，将结果添加到数组B中，同时移动数组B的最小数指向。
A和B 可以复用同一空间

### 时间
`Θ(n^2)`

### 元素移动
`Θ(n)`

## 插入排序

### 简述
```
step 1 ->（12, 9, 3, 7, 14, 11）
step 2 -> (9, 12, 3, 7, 14, 11)
step 3 -> (3, 9, 12, 7, 14, 11)
step 4 -> (3, 7, 9, 12, 14, 11)
step 5 -> (3, 7, 9, 12, 11, 14)
```
对A数组的已有顺序，依次取值对已有顺序进行对比插入。

### 时间
`Θ(n^2)`

### 位移
可能达到 `Θ(n^2)`

## 归并排序<font color=#ff4500>(分治递归)</font>

### 简述

![归并排序](归并排序.png)

### 时间
`Θ(nlgn)`

### 空间
对所有数组项进行拷贝

## 快速排序<font color=#ff4500>(分治递归)</font>

### 简述
设置主元，依照主元进行快速划分，然后对主元划分开的区域在做快速

### 空间
原址工作

### 时间
最坏 `Θ(n^2)`  平均 Θ(nlgn)   
渐进运行时间介于 __最坏__ 和 __平均__ 之间

__堆__
__冒泡__
__Shell排序__
__桶__


## 分治法
> 分解  
> 解决  
> 合并


## 总结对比
>查找          

| 算法 |最坏时间|最好时间|需要保证有序数组|
|:---:|:--:|:--:|:--:|:--:|
|线性|Θ(n)|Θ(1)|no|
|二分|Θ(lgn)|Θ(1)|yes|


>排序

| 算法 |最坏时间|最好时间|最坏交换|是否原址|
|:---:|:--:|:--:|:--:|:--:|
|选择|Θ(n^2)|Θ(n^2)|Θ(n)|yes|
|插入|Θ(n^2)|Θ(n)|Θ(n^2)|yes|
|归并|Θ(nlgn)|Θ(nlgn)|Θ(nlgn)|no|
|快速|Θ(n^2)|Θ(nlgn)|Θ(n^2)|yes|


 排序算法的下届和如何超越下届

## 计数排序

### 简述

![计数排序](计数排序.jpg)

统计集合(值<M)中出现的值的个数，值在有序表中出现的位置应该是统计值位数小于该只的和(相同值要加)


## 基数排序
> LSD (Least significant digital) 由数值的低位开始    
> MSD (Most significant ditital)  由数值的高位开始   
> LSD的基数排序适用于位数少的数列，位数多(十、分、百、千)，使用MSD的效率会比较好

### 简述
分配时 由末位向首位进行     
初始数列：10, 31, 112, 412, 0, 24

__LSD__    
>个位开始  
  
|序列|可选值|
|:-:|:-:|
|0|10|
|1|31|
|2|112，412|
|4|24|

结果数列：10, 31, 112, 412, 24

>十位

|序列|可选值|
|:-:|:-:|
|1|10，112，412|
|2|24|
|3|31|

结果数列：10, 112, 412, 24, 31

>百位

|序列|可选值|
|:-:|:-:|
|0|10，24，31|
|1|112|
|4|412|

结果数列：10, 24, 31, 112, 412


----
__有向无环图__
## 拓扑排序

### 简述
每次讲入度为0的节点步骤入栈，然后从有向无环图上摘去该节点和该节点的边

### 时间
n个顶点 m条边   
`Θ(n+m)`

__最短路径__ : 用于计算一个节点到其他所有节点的最短路径
## Dijkstra(迪杰斯特拉) 算法
> 贪心算法思想：是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法    
要求图里面所有的边的权值都是非负的    
![](./dijkstra1.jpg)


邻接表   

|初始点|(连接点:权重)|
|:-:|:-:|
|1|入度为0 (2:10),(4:30),(5:100)|
|2|(3:50)|
|3|(5:10)|
|4|(3:20),(5:60)|
|5|出度为0|

迭代过程

|S|u|2|3|4|5|
|:-:|:-:|:-:|:-:|:-:|:-:|
|{1}|null|10|∞|30|100|
|{1,2}|2| |60|30|100|
|{1,2,4}|4| |50||90|
|{1,2,4,3}|3| |||60|
|{1,2,4,3,5}|5| ||||

__克鲁斯卡尔__     
__普里姆__

## Bellman-Ford 算法

允许存在负权边, __最短路径最多包含(|v|-1)条边__

![](./Bellman-Ford.png)

根据最短路径生成的树高度进行迭代

迭代过程

`for edge(u,v) in E(G) do `

| tree deep | path | weight |
|:----:|:------:|:----:|
|   1  | 1 -> 2 |   1  |
|   2  | 1 -> 2 -> 3 | 3 |
|   3  | 1 -> 2 -> 3 -> 4 | -2 |

__迭代结束__   
接着    
__再对__ 每条边进行`RELAX`   

发现`shortest[2] < shotest[4] + weight(4,2)`

__则__ 存在负权值回路

### 算法优化
TODO: __SPFA算法__

## Floyd-Warshall 算法
> 动态规划 
建立顶点的二维数组，录入到达的权值。核心思想    
  
```
for(i = 1; i <= n; i++)  
        for(j = 1; j <= n; j++)  
            for(k = 1; k <= n; k++)  
                if(a[j][i] < inf && a[i][k] < inf && a[j][k] > a[j][i] + a[i][k])  
                    a[j][k] = a[j][i] + a[i][k]; 
```

### 时间

`Θ(n^3)`

------
__字符串__
> 子序列 {可不连续 顺序一定}     
> 公共子序列     
> 公共最长子序列     
> 子串 = {子序列+取值连续}    
